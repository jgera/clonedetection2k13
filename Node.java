import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

public class Node extends Thread{
	private int id;
	private Coordinate coord; //coordinate of the node in the Unite-Square Area
	private Float radius, prob;
	private int locations;
	private int energy, en_send, en_rec, en_sign;
	private int rand; //randomic int generated by hypervisor for RED protocol
	private Hypervisor parent;
	private ArrayList<Node> neigh = new ArrayList<Node>();
	private ArrayList<LocationClaim> messages =new ArrayList<LocationClaim>();
    private Map<Integer, Coordinate> m = new HashMap<Integer, Coordinate>(); //contains the map of the routed nodes coordinate
	private static String protocol;
	private static boolean foundClone=false;
	private int sent_messages=0;
	private int received_messages=0;
	private int sign_done=0;
	
	public Node(){}
	
	public Node(int cont_id, Coordinate coo_in, Float r, Float p, Integer g, Integer e,
			Integer e_send, Integer e_rec, Integer e_sign, Hypervisor par) {
		id= cont_id;		//the ID for the node
		coord= coo_in;		//coordinates of the node
		radius= r;			//communication radius of the node
		prob=p;				//Probability for a neighbour node to process a location claim
		locations=g;		//number of destination location
		energy=e;			//Total energy for the node
		en_send= e_send;	//Energy spent for sending a message
		en_rec= e_rec;		//Energy spent for receiving a message
		en_sign= e_sign;	//Energy for the signature of a message
		parent=par; 		//reference to the hypervisor
	}
	
	public int getNodeId(){
		return id;
	}
	
	public void setRand(int x){
		rand=x;
	}
	
	public Coordinate getCoord(){
		return coord;
	}
	
	public static void setProtocol(String s){
			protocol=s;
	}
	
	public static boolean getFoundClone(){
		return foundClone;
	}
	
	public static void setFoundClone(boolean fc){
		foundClone=fc;
	}
	
	public void insertNeigh(Node n){
		neigh.add(n);
	}
	
	public void clone(Node fromClone){	//clone a node
		id= fromClone.id;
		radius= fromClone.radius;
		prob= fromClone.prob;
		locations= fromClone.locations;
		energy= fromClone.energy;
		en_send= fromClone.en_send;
		en_rec= fromClone.en_rec;
		en_sign= fromClone.en_sign;
		parent= fromClone.parent;
	}
	
	public void setCoordinate(Coordinate cor){
		coord=cor;
	}
	
	public synchronized Map<Integer,Coordinate> getM(){
		return m;
	}
	
	public synchronized int final_energy(){
		return energy;
	}
	
	public synchronized int getSent(){
		return sent_messages;
	}
	
	public synchronized int getRec(){
		return received_messages;
	}
	
	public synchronized int getSign(){
		return sign_done;
	}
	
	public void sendLC(LocationClaim mess){
		if(!foundClone){	//if we have found the clone, don't proceed
		//push the message "mess" in this node buffer "messages"
			synchronized(messages){
				messages.add(mess);
				messages.notifyAll();
			}
		}
	}
	
	public void receiveLC(LocationClaim mess){	//receive the location claim for the first time
		if(!foundClone)	//if we have found the clone, don't proceed
			if(Math.random()>(1-prob)) //forward the message
				forward(mess);	
			//else ignore the location claim message
	}
	
	public synchronized void receiveLCForw(LocationClaim mess){	//receive the location claim in order to forwarding it
		if(!foundClone){	//if we have found the clone, don't proceed
			if(protocol.equals("LSM")){
				//in LSM, we have to control in every step if the clone is present
				if(energy>=en_sign){	//control if we have enough energy to verify the signature of the message
					//remove the energy for signing the message and increase the counter of the messages signed from this node
					energy-=en_sign;
					sign_done++;
					//get the coordinate of the mess.ID, if it's already present (else=null)
					Coordinate test=m.get(mess.getID());
					if(test!=null){	//message ID already present
						if(!test.equals(mess.getCoord()))	//same id, different coordinates = we've found the CLONE!
							founded_clone();
						else forw(mess);	//forward the message
					}
					else{	//message ID not present
						//save the message
						m.put(mess.getID(), mess.getCoord());
						forw(mess);	//forward the message
					}
				}
			}
			if(protocol.equals("RED"))	//in RED, we only have to forward the message
				forw(mess);	//forward the message
		}
	}
	
	public void forward(LocationClaim message){
		//the forward function,as called by the receiving of a message of location claim
		if(!foundClone){	//if we have found the clone, don't proceed
			//the first forwarding is different according to the protocol implemented
			if(protocol.equals("LSM")){
				for(int i=0;i<locations;i++){	//sent #=locations number of messages
					Double x= Math.random();
					Double y= Math.random();
					Coordinate dest= new Coordinate(x,y);
					//for every i=location g, clone the original message, changing only the destination coordinates
					LocationClaim mex_i=new LocationClaim();
					mex_i.clone(message);
					mex_i.setDestination(dest);
					forw(mex_i);	//complete the forwarding
				}
			}
			if(protocol.equals("RED")){
				try {
					MessageDigest md = MessageDigest.getInstance("MD5");	//hash function implements Java.Security protocol MD5
					for(int i=0;i<locations;i++){	//sent #=locations number of messages
						md.reset();
						md.update((byte)(message.getID()+rand+i));	//input: NodeID+randomNumber+g(forwarding iteration)
						byte[] digest = md.digest();	//calculate
						String x_s="0.", y_s="0.";
						for(int ix=0;ix<(digest.length/2);ix++)
							x_s+=Math.abs(digest[ix]);
						for(int iy=(digest.length/2);iy<digest.length;iy++)
							y_s+=Math.abs(digest[iy]);
						Double x= Double.parseDouble(x_s);	//x coordinate
						Double y= Double.parseDouble(y_s);	//y coordinate
						Coordinate dest=new Coordinate(x,y);
						//for every i=location g, clone the original message, changing only the destination coordinates
						LocationClaim mex_i= new LocationClaim();
						mex_i.clone(message);
						mex_i.setDestination(dest);
						forw(mex_i);	//complete the forwarding
					}
				}catch (NoSuchAlgorithmException e) {
					e.printStackTrace();
				}
			}	
		}
	}
	
	public synchronized void forw(LocationClaim message){
		if(!foundClone){	//if we have found the clone, don't proceed
			//the forward function,as called by the receiving of a message already forwarded
			//or as the ending of the forwarding of a location claim
			//***********************************************
			//find the closer node to the destination
			Node closer= this;
			Double distance_min= closer.getCoord().distance(message.getDestination());
			for(int i=0;i<neigh.size();i++){
				Double newdistance=neigh.get(i).getCoord().distance(message.getDestination());	//distance node_neighbor[i]-destination coordinates
				if(newdistance<distance_min){
					closer= neigh.get(i);
					distance_min= newdistance;
				}
			}
			//**********************************************
			if(closer!=this){ //there is a node closer to the destination
				if(!message.getForw()){	//useless if the message is already forwarded (getForw==true!)
					//so,if message.getForw()==false, it is a location claim to forward...
					message.setForw(true);
					//...and, if protocol==LSM, we have to save in the memory the message
					if(protocol.equals("LSM")){
						if(energy>=en_sign){	//control if we have enough energy to verify the signature of the message
							//remove the energy for signing the message and increase the counter of the messages signed from this node
							energy-=en_sign;
							sign_done++;
							//get the coordinate of the mess.ID, if it's already present (else=null)
							Coordinate test=m.get(message.getID());
							if(test!=null){	//message ID already present
								if(!test.equals(message.getCoord()))	//same id, different coordinates = we've found the CLONE!
									founded_clone();
								//else ID+coordinate already present, don't put it again in the hash of saved messages
							}
							else{	//message ID not present
								//save the message
								m.put(message.getID(), message.getCoord());
							}
						}
					}
				}
				//in every case, send the message
				if(energy>=en_send){	//control if we have enough energy to send the message
					//remove the energy for sending the message and increase the counter of the messages sent from this node
					energy-=en_send;
					sent_messages++;
					closer.sendLC(message);
				}
			}
			else{	//this is the closer node to the destination --> this is the final receiver
				if(energy>=en_sign){	//control if we have enough energy to verify the signature of the message
					//remove the energy for signing the message and increase the counter of the messages signed from this node
					energy-=en_sign;
					sign_done++;
					//get the coordinate of the mess.ID, if it's already present (else=null)
					Coordinate test=m.get(message.getID());
					if(test!=null){	//message ID already present
						if(!test.equals(message.getCoord()))	//same id, different coordinates = we've found the CLONE!
							founded_clone();
						//else ID+coordinate already present, don't put it again in the hash of saved messages
					}
					else{	//message ID not present
						//save the message
						m.put(message.getID(), message.getCoord());
					}
				}
			}
		}
	}
	
	public void founded_clone(){
		foundClone=true;	//static field, flag for the hypervisor
		synchronized(parent){	//let's warn the hypervisor we founded the clone
			parent.notify();
		}
		synchronized(messages){	//let's warn all the nodes!
			messages.notifyAll();
		}
	}
		
	public void run(){
		LocationClaim message= new LocationClaim(id, coord);	//create a LCMessage with id and coordinates of the node
		//the node send broadcast to its neighbors the locationclaim message
		for(int i=0;i<neigh.size();i++){
			if(energy>=en_send && energy>=en_sign){	//control if we have enough energy to send the message
													//or enough energy to sign it
				//remove the energy for sending the message and increase the counter of the messages sent from this node
				energy-=en_send;
				sent_messages++;
				//remove the energy for signing the message and increase the counter of the messages signed from this node
				energy-=en_sign;
				sign_done++;
				//send the message
				neigh.get(i).sendLC(message);
			}
		}
		
		LocationClaim mex=null;
		try {
			while(!foundClone){
				synchronized(messages){
					while(messages.isEmpty()){
						messages.wait();
					}	//exit from the wait status thanks to a notify
					
					if(energy>=en_rec){	//control if we have enough energy to receive the message
						//remove the energy for receiving a message and increase the counter of the messages received from this node
						energy-=en_rec;
						received_messages++;
						//receive the message
						mex= messages.remove(0);
					}
				}
				
				if(mex!=null){	//if we don't have energy to receive, mex=null!
					if(!mex.getForw())
						receiveLC(mex);
					else
						receiveLCForw(mex);
				}
			}
		}catch (InterruptedException e) {
			return;
		}
	}
}
