import java.util.*;

public class Node extends Thread{
	private int id;
	private Coordinate coord; //coordinate of the node in the Unite-Square Area
	private Float radius, prob;
	private int locations;
	private int energy, en_send, en_rec, en_sign;
	private int rand; //randomic int generated by hypervisor for RED protocol
	private ArrayList<Node> neigh = new ArrayList<Node>();
	private ArrayList<LocationClaim> messages =new ArrayList<LocationClaim>();
    private Map<Integer, Coordinate> m = new HashMap<Integer, Coordinate>(); //contains the map of the routed nodes coordinate
	private static String protocol;
	public Node(){}
	
	public Node(int cont_id, Coordinate coo_in, Float r, Float p, Integer g, Integer e,
			Integer e_send, Integer e_rec, Integer e_sign) {
		id= cont_id;		//the ID for the node
		coord= coo_in;		//coordinates of the node
		radius= r;			//communication radius of the node
		prob=p;				//Probability for a neighbour node to process a location claim
		locations=g;		//number of destination location
		energy=e;			//Total energy for the node
		en_send= e_send;	//Energy spent for sending a message
		en_rec= e_rec;		//Energy spent for receiving a message
		en_sign= e_sign;	//Energy for the signature of a message
	}
	
	public int getNodeId(){
		return id;
	}
	
	public boolean setRand(int x){
		rand=x;
		return true;
	}
	
	public Coordinate getCoord(){
		return coord;
	}
	
	public static void setProtocol(String s){
			protocol=s;
	}
	public void insertNeigh(Node n){
		neigh.add(n);
		System.out.println(this.getNodeId()+ " ha come vicino il nodo "+n.getNodeId());
	}
	
	public void clone(Node fromClone){
		id= fromClone.id;
		radius= fromClone.radius;
		prob= fromClone.prob;
		locations= fromClone.locations;
		energy= fromClone.energy;
		en_send= fromClone.en_send;
		en_rec= fromClone.en_rec;
		en_sign= fromClone.en_sign;
	}
	
	public void setCoordinate(Coordinate cor){
		coord=cor;
	}
	
	public synchronized ArrayList<LocationClaim> getMessages(){
		return messages;
	}
	
	public synchronized void sendLC(Node n, LocationClaim mess){
		System.out.println(this.getNodeId()+ "send message to" + n.getNodeId());
		n.getMessages().add(mess);
		notify();
	}
	
	public synchronized void receiveLC() throws InterruptedException{	//receive the location claim for the first time
		while(messages.isEmpty()){
			System.out.println("EMPTY 1!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
			wait();
		}
		messages.get(0);	//read the first message in the queue "messages"
		System.out.println(this.getNodeId()+ " receive message");
		if(Math.random()<=(1-prob)) //ignore the message
			messages.remove(0);
		else{ //forward the message
			Double x= Math.random();
			Double y= Math.random();
			Coordinate dest= new Coordinate(x,y);	//destination
			forward(messages.get(0),dest);
			messages.remove(0);
		}
	}
	
	public synchronized void receiveLCForw(Coordinate dest) throws InterruptedException{	//receive the location claim in order to forwarding it, LSM
		while(messages.isEmpty()){
			System.out.println("EMPTY 2!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
			wait();
		}
		//aggiungere controllo su energy finita
		energy-=en_rec;
		messages.get(0);	//read the first message in the queue "messages"
		System.out.println(this.getNodeId()+ " receive message forwarded");
		//inserire conto su locations!! (g)
		m.put(messages.get(0).getID(), messages.get(0).getCoord());
		//control if this id is already present
		//verify: spent energy for signature
		//controllo energia sufficiente
		energy-=en_sign;
		if(!m.get(messages.get(0)).equals(messages.get(0).getCoord())){	//same id, different coordinates = CLONE!
			System.out.println("CLONE" + messages.get(0).getID());
		}
		else forward(messages.get(0),dest);
		messages.remove(0);
	}
	
	public void forward(LocationClaim message, Coordinate dest){
		//the forwarding is different according to the protocol implemented
		System.out.println("Forwarding");
		if(protocol=="LSM"){
			Node closer= this;
			Double distance_min= closer.getCoord().distance(dest);
			for(int i=0;i<neigh.size();i++){
				Double newdistance=neigh.get(i).getCoord().distance(dest);
				if(newdistance<distance_min){
					closer= neigh.get(i);
					distance_min= newdistance;
				}
			}
			if(closer!=this && message.getNumLoc()!=0){ //there is a node closer to the destination and we can still forward
				energy-=en_send;
				sendLC(closer, message);
				//aggiungere controllo su energy finita
				try {	//neighbors receive the message
					closer.receiveLCForw(dest);
				} catch (InterruptedException e){
					// TODO Auto-generated catch block
					System.out.println("Unexpected stop occurred");
				}
				message.setNumLoc(message.getNumLoc()-1); 
			}
		//if(protocol=="RED"){}	
		}
	}
	
	/*public void locationClaimNeigh(){
		for(int i=0; i<neigh.size();i++ ){
			neigh.get(i).locationClaim(this, id, coord);//chiamo locationclaim per tutti i neighbor
			//Energy spent
			energy=energy-en_send;
		}
	}
	public void locationClaim(Node n, int idclaim, Coordinate c){
		//mettere controllo se ignorare o meno
		energy=energy-en_rec;
		if(m.containsKey(idclaim)) //devo controllare se esiste già questo nodo nella mappa??
			if(m.get(idclaim).equals(c)) //controllo se il nodo che ho in memoria ha la stessa coordinata del precedente claim
			{} //do nothing already present in map
			else
			{} // coordinate di stesso id non corrispondo _ ho trovato il clone?
		else
			m.put(idclaim,c);
	}*/
	
	public void run(){
		//il while() wait() presente nei receive non mi convince! vedere di spostare(?)
		//sennò alla fine non sarà mai in wait(),anche se dovrebbe esserlo!
		LocationClaim message= new LocationClaim(this.getNodeId(), this.getCoord(), locations);	//create a LCMessage with id and coordinates of the node
		//the node send broadcast to its neighbors the locationclaim message
		for(int i=0;i<neigh.size();i++){
			sendLC(neigh.get(i), message);
			//forse al posto del try il while di cui sopra è da mettere qui (?)
			try {	//neighbors receive the message
				neigh.get(i).receiveLC();
			} catch (InterruptedException e){
				// TODO Auto-generated catch block
				System.out.println("Unexpected stop occurred");
			}
		}
		//if(protocol=="RED");
		//if(protocol=="LSM");
	}
}
