import java.util.*;

public class Node extends Thread{
	private int id;
	private Coordinate coord; //coordinate of the node in the Unite-Square Area
	private Float radius, prob;
	private int locations;
	private int energy, en_send, en_rec, en_sign;
	private int rand; //randomic int generated by hypervisor for RED protocol
	private Hypervisor parent;
	private ArrayList<Node> neigh = new ArrayList<Node>();
	private ArrayList<LocationClaim> messages =new ArrayList<LocationClaim>();
    private Map<Integer, Coordinate> m = new HashMap<Integer, Coordinate>(); //contains the map of the routed nodes coordinate
	private static String protocol;
	private static boolean foundClone=false;
	//private static int mess_proceeded=0;
	private int sent_messages=0;
	private int received_messages=0;
	private int sign_done=0;
	
	public static int cloni=0;	//da togliere
	public Node(){}
	
	public Node(int cont_id, Coordinate coo_in, Float r, Float p, Integer g, Integer e,
			Integer e_send, Integer e_rec, Integer e_sign, Hypervisor par) {
		id= cont_id;		//the ID for the node
		coord= coo_in;		//coordinates of the node
		radius= r;			//communication radius of the node
		prob=p;				//Probability for a neighbour node to process a location claim
		locations=g;		//number of destination location
		energy=e;			//Total energy for the node
		en_send= e_send;	//Energy spent for sending a message
		en_rec= e_rec;		//Energy spent for receiving a message
		en_sign= e_sign;	//Energy for the signature of a message
		parent=par; 		//refer to hypervisor
	}
	
	public int getNodeId(){
		return id;
	}
	
	public boolean setRand(int x){
		rand=x;
		return true;
	}
	
	public Coordinate getCoord(){
		return coord;
	}
	
	public static void setProtocol(String s){
			protocol=s;
	}
	
	public static boolean getFoundClone(){
		return foundClone;
	}
	
	public static void setFoundClone(boolean fc){
		System.out.println("foundclone=false");
		foundClone=fc;
	}
	
	public void insertNeigh(Node n){
		neigh.add(n);
		//System.out.println(this.getNodeId()+ " ha come vicino il nodo "+n.getNodeId());
	}
	
	public void clone(Node fromClone){
		id= fromClone.id;
		radius= fromClone.radius;
		prob= fromClone.prob;
		locations= fromClone.locations;
		energy= fromClone.energy;
		en_send= fromClone.en_send;
		en_rec= fromClone.en_rec;
		en_sign= fromClone.en_sign;
		parent= fromClone.parent;
	}
	
	public void setCoordinate(Coordinate cor){
		coord=cor;
	}
	
	public synchronized ArrayList<LocationClaim> getMessages(){
		return messages;
	}
	
	public synchronized Map<Integer,Coordinate> getM(){
		return m;
	}
	
	public synchronized int final_energy(){
		return energy;
	}
	
	public synchronized int getSent(){
		return sent_messages;
	}
	
	public synchronized int getRec(){
		return received_messages;
	}
	
	public synchronized int getSign(){
		return sign_done;
	}
	
	public void sendLC(LocationClaim mess){
			synchronized(messages){
				//mess_proceeded++;	//MAH!
				messages.add(mess);
				messages.notifyAll();
				//System.out.println("Message sent");
			}
	}
	
	public synchronized void receiveLC(LocationClaim mess){	//receive the location claim for the first time
		if(!foundClone){	//if we have found the clone, don't proceed
			System.out.println(this.getNodeId()+ " receive message of claim location from "+ mess.getID());
			if(Math.random()<=(1-prob)){
				System.out.println("ignore"); //ignore the message
				//mess_proceeded--;
			}
			else{ //forward the message
				Double x= ((Math.random()*99)/100);
				Double y= ((Math.random()*99)/100);
				System.out.println(this.getCoord().getX()+ " "+ this.getCoord().getY());
				System.out.println(x+ " "+ y);
				Coordinate dest= new Coordinate(x,y);	//destination
				mess.setDestination(dest);
				forward(mess);
			}
		}	
	}
	
	public synchronized void receiveLCForw(LocationClaim mess){	//receive the location claim in order to forwarding it, LSM
		if(!foundClone){	//if we have found the clone, don't proceed
			System.out.println(this.getNodeId()+ " receive message forwarded");
			//inserire conto su locations!! (g)
			if(energy>=en_sign){	//control if we have enough energy to verify the signature of the message
				energy-=en_sign;
				sign_done++;
				Coordinate test=m.get(mess.getID());
				if(test!=null){	//message ID already present
					System.out.println("Già presente");
					if(!test.equals(mess.getCoord())){	//same id, different coordinates = CLONE!
						founded_clone();
					}
					else forward(mess);
				}
				else{	//message ID not present
					System.out.println("Nodo "+this.getNodeId()+ "salva in hash "+ mess.getID()+ ", coordinate "+mess.getCoord().getX()+ " "+mess.getCoord().getY());
					m.put(mess.getID(), mess.getCoord());
					forward(mess);
				}
			}
		}
	}
	
	public synchronized void forward(LocationClaim message){
		if(!foundClone){
			//the forwarding is different according to the protocol implemented
			Coordinate dest= message.getCoord();
			if(protocol=="LSM"){
				forw_lsm(message,dest);
			}
			//if(protocol=="RED"){}	
		}
	}
	
	public void forw_lsm(LocationClaim message, Coordinate dest){
		System.out.println("LSM");
		//find the closest node to the destination
		Node closer= this;
		System.out.println("closer before= "+this.getNodeId());
		Double distance_min= closer.getCoord().distance(dest);
		for(int i=0;i<neigh.size();i++){
			Double newdistance=neigh.get(i).getCoord().distance(dest);
			if(newdistance<distance_min){
				closer= neigh.get(i);
				distance_min= newdistance;
			}
		}
		System.out.println("closer after= "+closer.getNodeId());
		
		if(closer!=this && message.getNumLoc()!=0){ //there is a node closer to the destination and we can still forward
			message.setForw(true);
			System.out.println("Forwarding");
			message.setNumLoc(message.getNumLoc()-1);
			if(energy>=en_send){	//control if we have enough energy to send the message
				System.out.println(this.getNodeId()+" forward to " +closer.getNodeId());
				energy-=en_send;
				sent_messages++;
				closer.sendLC(message);
			}
		}
		if(closer==this){	//this is the closest node to the destination
			System.out.println("Save here!");
			if(energy>=en_send){	//control if we have enough energy to verify the signature of the message
				energy-=en_sign;
				sign_done++;
				Coordinate test=m.get(message.getID());
				if(test!=null){	//message ID already present
					System.out.println("Già presente");
					if(!test.equals(message.getCoord())){	//same id, different coordinates = CLONE!
						founded_clone();
					}
				}
				else{	//message ID not present
					System.out.println("Nodo "+this.getNodeId()+ "salva in hash "+ message.getID()+ ", coordinate "+message.getCoord().getX()+ " "+message.getCoord().getY());
					m.put(message.getID(), message.getCoord());
				}
			}
		}
	}
	
	public void founded_clone(){
		//System.out.println("CLONE" + message.getID());
		cloni++;	//test per contare i cloni trovati in 100 cicli
		foundClone=true;	//static field, flag for the hypervisor
		System.out.println("foundclone=true");
		synchronized(parent){
			parent.notify();
		}
		synchronized(messages){
			messages.notifyAll();
		}
	}
		
	public void run(){
		LocationClaim message= new LocationClaim(getNodeId(), getCoord(), locations);	//create a LCMessage with id and coordinates of the node
		//the node send broadcast to its neighbors the locationclaim message
		for(int i=0;i<neigh.size();i++){
			if(energy>=en_send){	//control if we have enough energy to send the message
				energy-=en_send;
				sent_messages++;
				neigh.get(i).sendLC(message);
			}
			//mess_proceeded++;
		}
		
		LocationClaim mex=null;
		try {
			while(!foundClone){
				synchronized(messages){
					while(messages.isEmpty()){
						System.out.println("Empty LOLOLOLOLOLOLOLOLOL?");
						messages.wait();
					}	//exit from the wait status thanks to a notify
					
					if(energy>=en_rec){	//control if we have enough energy to receive the message
						energy-=en_rec;
						received_messages++;
						mex= messages.remove(0);
					}
				}
				
				if(mex!=null){
					if(!mex.toForw())
						receiveLC(mex);
					else
						receiveLCForw(mex);
				}
			}
		}catch (InterruptedException e) {
			// TODO Auto-generated catch block
			System.out.println("Interrotto");
			messages.clear();
			return;
		}
	}
}
